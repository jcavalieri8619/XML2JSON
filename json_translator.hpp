/* 
 * File:   json_translator.hpp
 * Author: John Cavalieri
 *
 * Created on November 7, 2013, 10:41 PM
 */


#ifndef JSON_TRANSLATOR_HPP
#define	JSON_TRANSLATOR_HPP

#include "globals.hpp"
#include "XML_Tree.hpp"
#include "XMLelements.hpp"
#include <fstream>
#include <string>
#include <sstream>
#include <iomanip>
#include <vector>
#include <deque>
#include <tuple>


typedef XMLTree::Tree_node Tree_node;


enum ValueEntity
{
	OBJECT, ARRAY
} ;


enum delimiterType
{
	OpenObject, CloseObject, OpenArray, CloseArray, COMMA
} ;


enum lineType
{
	Opening, KeyVal, Closing, RootOpening, ArrayOpening
} ;


/**
 * XMLTree_JSON class provides set of utility functions
 * that serve as the workforce for the public method translator.
 * Nearly all methods are private, including constructor, because
 * this class is only meant to be instantiated to aid in the
 * translation process.  The static method initializeTranslator
 * instantiates an XMLTree_JSON object in the heap and passes
 * a pointer back to the user. The initializeTranslator method
 * is then passed to the XMLTree traversal method to populate
 * translator queue. To begin translating, use the pointer
 * generated by initializeTranslator to call XMLTree_JSON::translator.
 * 
 */
class XMLTree_JSON
{
private:



	/**
	 * private constructor initializes the name of the
	 * .json output by the translator
	 * @param fileName name of .json file
	 */
	XMLTree_JSON( const std::string fileName = "JSON_doc.json"  );


	/**
	 * copy constructor deleted to prevent copying
	 * @param orig 
	 */
	XMLTree_JSON( const XMLTree_JSON& orig ) = delete;



	/**
	 * counts the number of attributes and direct children
	 * of the XMLelement node at the front of the queue
	 * @return number children
	 */
	std::size_t countObjectChildren( )const;



	/**
	 * determines if the XMLelement at front of queue
	 * opens a JSON object
	 * @return true if opening object; else false
	 */
	bool isOpeningObject( )const;


	/**
	 * determines if the XMLelement at front of queue
	 * opens a JSON array
	 * @return true if opening array; else false
	 */
	bool isOpeningArray(   )const;



	/**
	 * determines if the XMLelement at front of the queue
	 * represents a single key value pair or equivalently
	 * a complete XML element
	 * @return true if single key value pair; else false
	 */
	bool isKeyValuePair(  )const;


	/**
	 * calls both isClosingObject and isClosingArray combined
	 * in a boolean OR.  
	 * @param whatNode node to test against current or prior
	 * state for closing
	 * @param prior indicates whether to test whatNode for closing against
	 * current state or prior state on state stack; current state is top
	 * and prior is one below top.
	 * @return true if either of the isClosing methods returns true; else false
	 */
	bool isClosing( const Tree_node* whatNode, bool prior = false )const;


	/**
	 * determines if the node indicated by whatNode represents a
	 * closing array node to either the current state or prior state
	 * @param whatNode node to check for closing
	 * @param prior pass in true to check prior state, else leave default
	 * as false to check current state
	 * @return true if whatNode closing the state indicated by prior; else false
	 */
	bool isClosingArray( const Tree_node* whatNode, bool prior = false )const;



	/**
	 * determines if the node indicated by whatNode represents a
	 * closing object node to either the current state or prior state
	 * @param whatNode node to check for closing
	 * @param prior pass in true to check prior state, else leave default
	 * as false to check current state
	 * @return true if whatNode closing the state indicated by prior; else false
	 */
	bool isClosingObject( const Tree_node* whatNode, bool prior = false )const;




	/**
	 * gathers all the necessary data to describe the
	 * state of the translator for each node processed
	 * @param depth depth of the current node
	 * @param name name of the current node
	 * @param indentLevel current indent level
	 */
	void gatherStateData( std::size_t& depth, std::string& name,
						 std::size_t& indentLevel )const;




	/**
	 * extracts the valueEntity value from the state tuple
	 * passed in as argument; typically used to extract
	 * tuple elements from the getCurrentState or getPriorState
	 * methods
	 * @param state tuple from state stack
	 * @return either ARRAY or OBJECT depending on what node
	 * generated the state and whether the node opened an ARRAY
	 * or OBJECT
	 */
	ValueEntity state_extractEntity(  std::tuple<ValueEntity,
									 std::size_t, std::string,
									 std::size_t> state )const;


	/**
	 * extracts the node depth from state tuple
	 * @param state tuple from state stack
	 * @return depth of the node that generated state tuple
	 */
	std::size_t state_extractDepth(  std::tuple<ValueEntity,
								 std::size_t, std::string,
								 std::size_t> state )const;


	/**
	 * extracts the indent level from state tuple
	 * @param state tuple from state stack
	 * @return indent level that existed when state tuple
	 * was pushed onto stack
	 */
	std::size_t state_extractIndentLevel( std::tuple<ValueEntity,
										 std::size_t, std::string,
										 std::size_t> state )const;


	/**
	 * extracts the name of the node from state tuple
	 * @param state tuple from state stack
	 * @return name of the opening array node or opening object node
	 */
	std::string state_extractName(  std::tuple<ValueEntity,
								 std::size_t, std::string,
								 std::size_t> state )const;


	/**
	 * gets the top tuple from state stack but does not
	 * pop the tuple
	 * @return top state tuple
	 */
	std::tuple<ValueEntity, std::size_t,
	std::string, std::size_t> getCurrentState( )const;


	/**
	 * pushed state tuple
	 * @param value ARRAY or OBJECT
	 * @param depth depth of the node
	 * @param name name of the node
	 * @param indentLevel indent level that existed
	 * when tuple was pushed
	 */
	void pushState( ValueEntity value, std::size_t depth,
				 std::string name, std::size_t indentLevel );


	/**
	 * determines if state stack is empty
	 * @return true if empty; else false
	 */
	bool StateStackEmpty( )const;


	/**
	 * gets the number of tuples on the state stack
	 * @return number of states current on stack
	 */
	std::size_t StateStackSize( )const;



	/**
	 * pops the top tuple from state stack
	 */
	void popState( );



	/**
	 * determines if the node queue is empty
	 * @return true if empty; else false
	 */
	bool NodeQueueEmpty( )const;


	/**
	 * pushes an XMLelement into the queue
	 * @param node XMLelement pointer 
	 */
	void pushNode( const Tree_node * node );


	/**
	 * pops the front node off the queue
	 */
	void popFrontNode( );



	/**
	 * inserts JSON delimiter into the stream used
	 * to build the current line
	 * @param formJSONLine stream used to build the current line
	 * @param delimiter delimiter type to insert
	 */
	void insertDelimiter( std::stringstream& formJSONLine,
						 delimiterType delimiter )const;


	/**
	 * gathers XMLelement content and attributes into a vector of pairs
	 * for node processing
	 * @param nodalPairs vector of string pairs to hold attributes
	 */
	void gatherNodalData( std::vector<std::pair<std::string, std::string> > & nodalPairs );



	/**
	 * generates the JSON document line by line 
	 * @param formJSONLine stream used to build the current line
	 * @param type type of line to build
	 * @param nodalPairs  current node's attributes and content
	 */
	void generateOutput( std::stringstream& formJSONLine, lineType type,
						 const std::vector<std::pair<std::string, std::string> > & nodalPairs );


	/**
	 * determines if the current key value pair requires a
	 * comma 
	 * @return  true if comma needed; else false
	 */
	bool isCommaNeeded( )const;



	/**
	 * determines if the current closing delimiter i.e "]" or "}"
	 * requires a comma
	 * @return true if comma needed; else false
	 */
	bool isClosingCommaNeeded( )const;



	/**
	 * inserts comma into the stream representing current JSON line
	 * @param formJSONLine current JSON line
	 */
	void insertComma( std::stringstream& formJSONLine )const;



	/**
	 * inserts key value pairs into the stream representing the
	 * current JSON line
	 * @param formJSONLine stream current JSON line
	 * @param key the key
	 * @param val the value; may be empty if opening key value line
	 */
	void insertKeyValuePair( std::stringstream& formJSONLine,
							 std::string key, std::string val = "" )const;


	/**
	 * gets the current indent level used to generate
	 * hierarchical JSON format
	 * @return indent level
	 */
	std::size_t getIndentSize( )const;


	/**
	 * gets the current node depth
	 * @return node depth
	 */
	std::size_t getCurrentNodeDepth( )const;



	/**
	 * sets the current indent level; after closing each value
	 * the indent level is set to the closing states indent level
	 * so that if a node closes multiple states; the JSON document
	 * will resume building at proper indent level
	 * @param size indent level
	 */
	void setIndentSize( std::size_t size );


	/**
	 * increments indent level by 2 after
	 * each new opening value
	 */
	void incrementIndent( );



	/**
	 * write the current JSON line to the output file
	 * @param JSONLine stream representing current JSON line
	 * @return ERRROR if write failed; else OK
	 */
	STATUS writeJSONLine( std::stringstream& JSONLine );


	/**
	 * gets the state tuple directly beneath the top
	 * state; required to ensure that objects opening
	 * inside an array are generated correctly
	 * @return state tuple
	 */
	std::tuple<ValueEntity, std::size_t,
	std::string, std::size_t> getPriorState( )const;



	/**
	 * gets the size of the node queue
	 * @return number of nodes in queue
	 */
	std::size_t NodeQueueSize( )const;



	/**
	 * gets the node at the indicated index
	 * @param whatNodeIndex index into queue
	 * @return pointer to the node at index
	 */
	const Tree_node * getQueuedNode( std::size_t whatNodeIndex )const;


	/**
	 * stack that contains the state of the translator
	 * for each node processed
	 */
	std::vector<std::tuple<ValueEntity,
	std::size_t, std::string, std::size_t> > StateStack;


	/**
	 * indent size used to generate hierarchical JSON format
	 */
	std::size_t indentSize;


	/**
	 * output file stream for .json document output
	 */
	std::ofstream fileOutput;


	/**
	 * node queue populated by tree traversal 
	 */
	std::deque<const Tree_node *> NodeQueue;


	/**
	 * a pointer to the XMLTree_JSON object
	 * generated by initializeTranslator. Given that
	 * this class has a private constructor, this
	 * data member ensures proper resource deallocation
	 * 
	 */
	XMLTree_JSON * const THIS_Translator;


public:

	/**
	 * the first call to this method requires
	 * the signature (null, &object) where object has
	 * type XMLTree_JSON* - this first call instantiates
	 * an XMLTree_JSON object in the heap and passes it back
	 * to user through object parameter.  To finish initialization,
	 * a pointer to this function is passed to XMLTree preOrder_traverse.
	 * This will completely populate the queue and initialization is complete.
	 * Now the generated pointer is used to access the translator method
	 * @param tree
	 * @param object
	 * @return 
	 */
	static STATUS initializeTranslator( Tree_node * tree,
									 XMLTree_JSON* * object );


	/**
	 * once a pointer to XMLTree_JSON object is obtained
	 * through initializeTranslator, and the initialization
	 * process is complete; this method will convert the XMLTree
	 * to a .json file.
	 * @return ERROR is an error occurs during translation; else OK
	 */
	STATUS translator( );


	/**
	 * deletes the XMLTree_JSON pointer allocated by initializeTranslator
	 */
	~XMLTree_JSON( );


} ;

#endif	/* JSON_TRANSLATOR_HPP */

